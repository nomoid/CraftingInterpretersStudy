1. A regular grammar (Type 3) is a restrictive type of grammar where all productions are of the form `A -> xB` and `A -> x` where `A, B` are non terminal and `x` is terminal (for right regular grammars) and of the form `A -> Bx` and `A -> x` where `A, B` are non terminal and `x` is terminal (for left regular grammars). The regular grammars generate exactly all regular languages. The advantage of having a regular grammar is that it is easier to parse, but the disadvantage is that it has less expressive power than non-regular languages (such as languages with a context-free or context-sensitive grammar). The lexical grammar of Python and Haskell are not regular, because regular languages (in fact context-free languages) cannot express the rules of indentaation ([source](https://cs.stackexchange.com/questions/77989/is-python-a-context-free-language)), which have semantic meaning in both these languages.

2. In Ruby, function calls need to not have spaces between the identifier and the parenthases holding the argments. This is because, functions can be called without parenthases, and tuples are also defined by parenthases, so having extra whitespace is as if the function is being called with a single-argument tuple instead of an argument list.
In the C preprocessor, spaces in definitions result in spaces when the definition is used. For example, with `#define F(x) (x)# and #define F(x) (x )# result in different text being produced in the output (the latter produces an extra space).

3. A scanner that does not discard those might be useful as a code formatter, or as a documentation generator. The former would need the comments and whitespace because it needs to figure out how to adjust those for proper formatting, while the latter would need the comments to generate the documentation.
